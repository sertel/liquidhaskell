<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Specifications - LiquidHaskell</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/color-brewer.min.css">

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">LiquidHaskell</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href=".." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../install/" class="nav-link">Install</a>
                            </li>
                            <li class="navitem">
                                <a href="../run/" class="nav-link">Run</a>
                            </li>
                            <li class="navitem">
                                <a href="../options/" class="nav-link">Options</a>
                            </li>
                            <li class="navitem active">
                                <a href="./" class="nav-link">Specifications</a>
                            </li>
                            <li class="navitem">
                                <a href="../contributing/" class="nav-link">Community</a>
                            </li>
                            <li class="navitem">
                                <a href="../develop/" class="nav-link">Developer's Guide</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../options/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../contributing/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#writing-specifications" class="nav-link">Writing Specifications</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#modules-without-code" class="nav-link">Modules WITHOUT code</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#modules-with-code-data" class="nav-link">Modules WITH code: Data</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#modules-with-code-functions" class="nav-link">Modules WITH code: Functions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#modules-with-code-type-classes" class="nav-link">Modules WITH code: Type Classes</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#modules-with-code-quasiquotation" class="nav-link">Modules WITH code: QuasiQuotation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#standalone-specifications-for-internal-modules" class="nav-link">Standalone Specifications for Internal Modules</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#inductive-predicates" class="nav-link">Inductive Predicates</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#implicit-arguments" class="nav-link">Implicit Arguments</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#refinement-type-aliases" class="nav-link">Refinement Type Aliases</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#infix-operators" class="nav-link">Infix  Operators</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#specifying-measures" class="nav-link">Specifying Measures</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#inlines" class="nav-link">Inlines</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#self-invariants" class="nav-link">Self-Invariants</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#abstract-and-bounded-refinements" class="nav-link">Abstract and Bounded Refinements</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#dependent-pairs" class="nav-link">Dependent Pairs</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#invariants" class="nav-link">Invariants</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#rewriting" class="nav-link">Rewriting</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#formal-grammar-of-refinement-predicates" class="nav-link">Formal Grammar of Refinement Predicates</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#constants" class="nav-link">(C)onstants</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#variables" class="nav-link">(V)ariables</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#expressions" class="nav-link">(E)xpressions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#relations" class="nav-link">(R)elations</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#predicates" class="nav-link">(P)redicates</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#specifying-qualifiers" class="nav-link">Specifying Qualifiers</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#by-separate-hquals-files" class="nav-link">By Separate .hquals Files</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#by-including-hquals-files" class="nav-link">By Including .hquals Files</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#in-haskell-source-or-spec-files" class="nav-link">In Haskell Source or Spec Files</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#termination-metrics" class="nav-link">Termination Metrics</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#synthesis" class="nav-link">Synthesis</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="writing-specifications">Writing Specifications</h1>
<h2 id="modules-without-code">Modules WITHOUT code</h2>
<p>When checking a file <code>target.hs</code>, you can specify an <em>include</em> directory by</p>
<pre><code>liquid -i /path/to/include/  target.hs
</code></pre>
<p>Now, to write specifications for some <strong>external module</strong> <code>Foo.Bar.Baz</code> for which
you <strong>do not have the code</strong>, you can create a <code>.spec</code> file at:</p>
<pre><code>/path/to/include/Foo/Bar/Baz.spec
</code></pre>
<p>See, for example, the contents of</p>
<ul>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/Prelude.spec">include/Prelude.spec</a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/Data/List.spec">include/Data/List.spec</a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/Data/Vector.spec">include/Data/Vector.spec</a></li>
</ul>
<p><strong>Note</strong>:</p>
<ul>
<li>The above directories are part of the LH prelude, and included by
  default when running <code>liquid</code>.</li>
<li>The <code>.spec</code> mechanism is <em>only for external modules</em><em> without code,
  see below for standalone specifications for </em><em>internal</em><em> or </em><em>home</em>* modules.</li>
</ul>
<h2 id="modules-with-code-data">Modules WITH code: Data</h2>
<p>Write the specification directly into the .hs or .lhs file,
above the data definition. See, for example, <a href="tests/pos/Map.hs">tests/pos/Map.hs</a></p>
<pre><code>{-@
data Map k a &lt;l :: k -&gt; k -&gt; Prop, r :: k -&gt; k -&gt; Prop&gt;
  = Tip
  | Bin (sz    :: Size)
        (key   :: k)
        (value :: a)
        (left  :: Map &lt;l, r&gt; (k &lt;l key&gt;) a)
        (right :: Map &lt;l, r&gt; (k &lt;r key&gt;) a)
@-}
data Map k a = Tip
             | Bin Size k a (Map k a) (Map k a)
</code></pre>
<p>You can also write invariants for data type definitions
together with the types. For example, see <a href="tests/pos/record0.hs">tests/pos/record0.hs</a></p>
<pre><code>{-@ data LL a = BXYZ { size  :: {v: Int | v &gt; 0 }
                     , elems :: {v: [a] | (len v) = size }
                     }
@-}
</code></pre>
<p>Finally you can specify the variance of type variables for data types.
For example, see <a href="tests/pos/Variance.hs">tests/pos/Variance.hs</a>, where data type <code>Foo</code> has four
type variables <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, specified as invariant, bivariant,
covariant and contravariant, respectively.</p>
<pre><code>data Foo a b c d
{-@ data variance Foo invariant bivariant covariant contravariant @-}
</code></pre>
<h2 id="modules-with-code-functions">Modules WITH code: Functions</h2>
<p>Write the specification directly into the .hs or .lhs file,
above the function definition. <a href="tests/pos/spec0.hs">For example</a></p>
<pre><code>{-@ incr :: x:{v: Int | v &gt; 0} -&gt; {v: Int | v &gt; x} @-}
incr   :: Int -&gt; Int
incr x = x + 1
</code></pre>
<h2 id="modules-with-code-type-classes">Modules WITH code: Type Classes</h2>
<p>Write the specification directly into the .hs or .lhs file,
above the type class definition. <a href="tests/pos/Class.hs">For example</a></p>
<pre><code>{-@ class Sized s where
      size :: forall a. x:s a -&gt; {v:Int | v = (size x)}
@-}
class Sized s where
  size :: s a -&gt; Int
</code></pre>
<p>Any measures used in the refined class definition will need to be
<em>generic</em> (see <a href="#specifying-measures">Specifying Measures</a>).</p>
<p>As an alternative, you can refine class instances.
<a href="tests/classes/pos/Inst00.hs">For example</a></p>
<pre><code>instance Compare Int where

{-@ instance Compare Int where
    cmax :: Odd -&gt; Odd -&gt; Odd
  @-}

cmax y x = if x &gt;= y then x else y
</code></pre>

<p>When <code>cmax</code> method is used on <code>Int</code>, liquidHaskell will give it
the refined type <code>Odd -&gt; Odd -&gt; Odd</code>.</p>
<p>Note that currently liquidHaskell does not allow refining instances of
refined classes.</p>
<h2 id="modules-with-code-quasiquotation">Modules WITH code: QuasiQuotation</h2>
<p>Instead of writing both a Haskell type signature <em>and</em> a
LiquidHaskell specification for a function, the <code>lq</code>
quasiquoter in the <code>LiquidHaskell</code> module can be used
to generate both from just the LiquidHaskell specification.</p>
<pre><code class="haskell">module Nats (nats) where

{-@ nats :: [{v:Int | 0 &lt;= v}] @-}
nats :: [Int]
nats = [1,2,3]
</code></pre>

<p>can be written as</p>
<pre><code class="haskell">{-# LANGUAGE QuasiQuotes #-}
module Nats (nats) where

import LiquidHaskell

[lq| nats :: [{v:Int | 0 &lt;= v}] |]
nats = [1,2,3]
</code></pre>

<p>and the <code>lq</code> quasiquoter will generate the plain <code>nats :: [Int]</code> when GHC
compiles the module.</p>
<p>Refined type aliases (see the next section) can also be written inside <code>lq</code>; for
example:</p>
<pre><code class="haskell">{-# LANGUAGE QuasiQuoters #-}
module Nats (Nat, nats) where

[lq| type Nat = {v:Int | 0 &lt;= v} |]

[lq| nats :: [Nat] |]
nats = [1,2,3]
</code></pre>

<p>Here, the <code>lq</code> quasiquoter will generate a plain Haskell
type synonym for <code>Nat</code> as well as the refined one.</p>
<p>Note that this is still an experimental feature, and
currently requires that one depend on LiquidHaskell
as a build dependency for your project; the quasiquoter
will be split out eventually into an independent,
dependency-light package. Also, at this time, writing
a type inside <code>lq</code> which refers to a refined type alias
for which there is not a plain Haskell type synonym of the
same name will result in a "not in scope" error from GHC.</p>
<h2 id="standalone-specifications-for-internal-modules">Standalone Specifications for Internal Modules</h2>
<p>Recall that the <code>.spec</code> mechanism is only for modules whose
code is absent; if code is present then there can be multiple,
possibly conflicting specifications. Nevertheless, you may want,
for one reason or another, to write (assumed) specifications
outside the file implementing the module.</p>
<p>You can do this as follows.</p>
<p><code>Lib.hs</code></p>
<pre><code class="haskell">module Lib (foo) where

foo a = a
</code></pre>

<p>now, instead of a <code>.spec</code> file, just use a haskell module, e.g. <code>LibSpec.hs</code></p>
<pre><code class="haskell">module LibSpec ( module Lib ) where

import Lib

-- Don't forget to qualify the name!

{-@ Lib.foo :: {v:a | false} -&gt; a @-}
</code></pre>

<p>and then here's <code>Client.hs</code></p>
<pre><code class="haskell">module Client where

import Lib      -- use this if you DON'T want the spec
import LibSpec  -- use this if you DO want the spec, in addition to OR instead of the previous import.

bar = foo 1     -- if you `import LibSpec` then this call is rejected by LH
</code></pre>

<h2 id="inductive-predicates">Inductive Predicates</h2>
<p><strong>Very Experimental</strong></p>
<p>LH recently added support for <em>Inductive Predicates</em>
in the style of Isabelle, Coq etc. These are encoded
simply as plain Haskell GADTs but suitably refined.</p>
<p>Apologies for the minimal documentation; see the
following examples for details:</p>
<ul>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/tests/ple/pos/IndEven.hs">Even and Odd</a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/tests/ple/pos/IndPerm.hs">Permutations</a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/tests/ple/pos/IndStar.hs">Transitive Closure</a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/tests/ple/pos/RegexpDerivative.hs">RegExp Derivatives</a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/tests/ple/pos/STLC2.hs">Type Safety of STLC</a></li>
</ul>
<h2 id="implicit-arguments">Implicit Arguments</h2>
<p><strong>Experimental</strong></p>
<p>There is experimental support for implicit arguments, solved for with congruence closure. For example, consider <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/tests/pos/Implicit1.hs">Implicit1.hs</a>:</p>
<pre><code class="haskell">{-@ type IntN N = {v:Int | v = N} @-}

{-@ foo :: n:Int ~&gt; (() -&gt; IntN n) -&gt; IntN {n+1} @-}
foo f = 1 + f ()

{-@ test1 :: IntN 11 @-}
test1 = foo (\_ -&gt; 10)
</code></pre>

<p>Here, the refinement on <code>(\_ -&gt; 10) :: Int -&gt; { v:Int | v = 10 }</code> allows us to solve for <code>n = 10</code>, the implicit argument to <code>foo</code>.</p>
<h2 id="refinement-type-aliases">Refinement Type Aliases</h2>
<h4 id="predicate-aliases">Predicate Aliases</h4>
<p>Often, the propositions in the refinements can get rather long and
verbose. You can write predicate aliases like so:</p>
<pre><code>{-@ predicate Lt X Y = X &lt; Y        @-}
{-@ predicate Ge X Y = not (Lt X Y) @-}
</code></pre>
<p>and then use the aliases inside refinements, <a href="tests/pos/pred.hs">for example</a></p>
<pre><code>{-@ incr :: x:{v:Int | (Pos v)} -&gt; { v:Int | ((Pos v) &amp;&amp; (Ge v x))} @-}
incr :: Int -&gt; Int
incr x = x + 1
</code></pre>
<p>See <a href="benchmarks/esop2013-submission/Base.hs">Data.Map</a> for a more substantial
and compelling example.</p>
<p><strong>Syntax:</strong> The key requirements for type aliases are:</p>
<ul>
<li>Value parameters are specified in <strong>upper</strong>case: <code>X</code>, <code>Y</code>, <code>Z</code> etc.</li>
</ul>
<h4 id="failing-specifications">Failing Specifications</h4>
<p>The <code>fail b</code> declaration checks that the definition of <code>b</code> is unsafe. E.g., the followin is SAFE.</p>
<pre><code>{-@ fail unsafe @-}
{-@ unsafe :: () -&gt; { 0 == 1 } @-}
unsafe :: () -&gt; () 
unsafe _ = ()
</code></pre>
<p>An error is created if <code>fail</code> definitions are safe or binders defined as <code>fail</code> are used by (failing or not) definitions. </p>
<h4 id="type-aliases">Type Aliases</h4>
<p>Similarly, it is often quite tedious to keep writing</p>
<pre><code>{v: Int | v &gt; 0}
</code></pre>
<p>Thus, LiquidHaskell supports refinement-type aliases of the form:</p>
<pre><code>{-@ type Gt      N = {v: Int | N &lt;  v} @-}
{-@ type GeNum a N = {v: a   | N &lt;= v} @-}
</code></pre>
<p>or</p>
<pre><code>{-@ type SortedList a = [a]&lt;{\fld v -&gt; (v &gt;= fld)}&gt; @-}
</code></pre>
<p>or</p>
<pre><code>{-@ type OMap k a = Map &lt;{\root v -&gt; v &lt; root}, {\root v -&gt; v &gt; root}&gt; k a @-}
</code></pre>
<p>or</p>
<pre><code>{-@ type MinSPair a = (a, OSplay a) &lt;\fld -&gt; {v : Splay {v:a|v&gt;fld} | 0=0}&gt; @-}
</code></pre>
<p>and then use the above in signatures like:</p>
<pre><code>{-@ incr: x: Int -&gt; GeNum Int x @-}
</code></pre>
<p>or</p>
<pre><code>{-@ incr: x: Int -&gt; Gt x @-}
</code></pre>
<p>and:</p>
<pre><code>{-@ assert insert :: (Ord a) =&gt; a -&gt; SortedList a -&gt; SortedList a @-}
</code></pre>
<p>see <a href="tests/pos/ListSort.hs">tests/pos/ListSort.hs</a></p>
<p>and:</p>
<pre><code>{-@ assert insert :: (Ord k) =&gt; k -&gt; a -&gt; OMap k a -&gt; OMap k a @-}
</code></pre>
<p>see <a href="tests/pos/Map.hs">tests/pos/Map.hs</a></p>
<p><strong>Syntax:</strong> The key requirements for type aliases are:</p>
<ol>
<li>Type parameters are specified in <strong>lower</strong>case: <code>a</code>, <code>b</code>, <code>c</code> etc.</li>
<li>Value parameters are specified in <strong>upper</strong>case: <code>X</code>, <code>Y</code>, <code>Z</code> etc.</li>
</ol>
<h2 id="infix-operators">Infix  Operators</h2>
<p>You can define infix types and logical operators in logic <a href="https://www.haskell.org/onlinereport/decls.html#fixity">Haskell's infix notation</a>.
For example, if <code>(+++)</code> is defined as a measure or reflected function, you can use it infix by declaring</p>
<pre><code>{-@ infixl 9 +++ @-}
</code></pre>
<p>Note: infix operators cannot contain the dot character <code>.</code>.</p>
<p>If <code>(==&gt;)</code> is a Haskell infix type (<a href="tests/pos/T1567.hs">see</a>) </p>
<pre><code>infixr 1 ==&gt;
</code></pre>
<p>then to use it as infix in the refinements types you need to add the refinement infix notation. </p>
<pre><code>{-@ infixr 1 ==&gt; @-}
{-@ test :: g:(f ==&gt; g) -&gt; f x -&gt; f y -&gt; ()  @-}
</code></pre>
<h2 id="specifying-measures">Specifying Measures</h2>
<p>Can be placed in .spec file or in .hs/.lhs file wrapped around <code>{-@ @-}</code></p>
<p>Value measures: <a href="include/GHC/Base.spec">include/GHC/Base.spec</a></p>
<pre><code>measure len :: forall a. [a] -&gt; GHC.Types.Int
len ([])     = 0
len (y:ys)   = 1 + len(ys)
</code></pre>
<p>Propositional measures: <a href="tests/pos/LambdaEval.hs">tests/pos/LambdaEval.hs</a></p>
<pre><code>{-@
measure isValue      :: Expr -&gt; Bool
isValue (Const i)    = true
isValue (Lam x e)    = true
isValue (Var x)      = false
isValue (App e1 e2)  = false
isValue (Plus e1 e2) = false
isValue (Fst e)      = false
isValue (Snd e)      = false
isValue (Pair e1 e2) = ((? (isValue(e1))) &amp;&amp; (? (isValue(e2))))
@-}
</code></pre>
<p>Raw measures: <a href="tests/pos/meas8.hs">tests/pos/meas8.hs</a></p>
<pre><code>{-@ measure rlen :: [a] -&gt; Int
rlen ([])   = {v | v = 0}
rlen (y:ys) = {v | v = (1 + rlen(ys))}
@-}
</code></pre>
<p>Generic measures: <a href="tests/pos/Class.hs">tests/pos/Class.hs</a></p>
<pre><code>{-@ class measure size :: a -&gt; Int @-}
{-@ instance measure size :: [a] -&gt; Int
    size ([])   = 0
    size (x:xs) = 1 + (size xs)
@-}
{-@ instance measure size :: Tree a -&gt; Int
    size (Leaf)       = 0
    size (Node x l r) = 1 + (size l) + (size r)
@-}
</code></pre>
<p><strong>Note:</strong> Measure names <strong>do not</strong> have to be the same as
field name, e.g. we could call the measure <code>sz</code> in the above
as shown in <a href="tests/pos/Class2.hs">tests/pos/Class2.hs</a>.</p>
<p>Haskell Functions as Measures (beta): <a href="tests/pos/HaskellMeasure.hs">tests/pos/HaskellMeasure.hs</a></p>
<p>Inductive Haskell Functions from Data Types to some type can be lifted to logic</p>
<pre><code class="haskell">    {-@ measure llen @-}
    llen        :: [a] -&gt; Int
    llen []     = 0
    llen (x:xs) = 1 + llen xs
</code></pre>

<p>The above definition
  - refines list's data constructors types with the llen information, and
  - specifies a singleton type for the haskell function
        <code>llen :: xs:[a] -&gt; {v:Int | v == llen xs}</code>
    If the user specifies another type for llen, say
        <code>llen :: xs:[a] -&gt; {v:Int | llen xs &gt;= 0}</code>
    then the auto generated singleton type is overwritten.</p>
<h2 id="inlines">Inlines</h2>
<p>The <code>inline</code>  lets you use a Haskell function in a type specification. </p>
<pre><code>{-@ inline max @-}
{-@ max :: Int -&gt; Int -&gt; Int @-}
max :: Int -&gt; Int -&gt; Int
max x y = if x &gt; y then x else y
</code></pre>

<p>For example, if you write the above you can then write a function:</p>
<pre><code class="haskell">{-@ floor :: x:Int -&gt; {v:Int | max 0 x} @-}
floor :: Int -&gt; Int
floor x 
  | x &lt;= 0    = 0
  | otherwise = x
</code></pre>

<p>That is, you can use the haskell <code>max</code> in the refinement type and 
it will automatically get “expanded” out to the full definition. 
This makes it useful e.g. to reuse plain Haskell code to compose 
specifications, and to share definitions common to refinements and code.</p>
<p>However, as they are <em>expanded</em> at compile time, <code>inline</code> functions 
<strong>cannot be recursive</strong>. The can call <em>other</em> (non-recursive) inline functions.</p>
<p>If you want to talk about arbitrary (recursive) functions inside your types, 
then you need to use <code>reflect</code> described [in the blog] (https://ucsd-progsys.github.io/liquidhaskell-blog/tags/reflection.html)</p>
<h1 id="self-invariants">Self-Invariants</h1>
<p>Sometimes, we require specifications that allow <em>inner</em> components of a
type to refer to the <em>outer</em> components, typically, to measure-based
properties of outer components. For example, the following invariant
about <code>Maybe</code> values</p>
<pre><code>{-@ type IMaybe a = {v0 : Maybe {v : a | ((isJust v0) &amp;&amp; v = (fromJust v0))} | 0 = 0 } @-}
</code></pre>
<p>states that the <em>inner</em> <code>a</code> enjoys the property that the <em>outer</em> container
is definitely a <code>Just</code> and furthermore, the inner value is exactly the same
as the <code>fromJust</code> property of the outer container.</p>
<p>As another example, suppose we have a <a href="include/Data/Set.spec">measure</a>:</p>
<pre><code>measure listElts :: [a] -&gt; (Set a)
listElts([])   = {v | (? Set_emp(v))}
listElts(x:xs) = {v | v = Set_cup(Set_sng(x), listElts(xs)) }
</code></pre>
<p>Now, all lists enjoy the property</p>
<pre><code>{-@ type IList a = {v0 : List  {v : a | (Set_mem v (listElts v0)) } | true } @-}
</code></pre>
<p>which simply states that each <em>inner</em> element is indeed, a member of the
set of the elements belonging to the entire list.</p>
<p>One often needs these <em>circular</em> or <em>self</em> invariants to connect different
levels (or rather, to <em>reify</em> the connections between the two levels.) See
<a href="tests/pos/maybe4.hs">this test</a> for a simple example and <code>hedgeUnion</code> and
<a href="benchmarks/esop2013-submission/Base.hs">Data.Map.Base</a> for a complex one.</p>
<h1 id="abstract-and-bounded-refinements">Abstract and Bounded Refinements</h1>
<p>This is probably the best example of the abstract refinement syntax:</p>
<ul>
<li><a href="tests/pos/Map.hs">Abstract Refinements</a></li>
<li><a href="benchmarks/icfp15/pos/Overview.lhs">Bounded Refinements</a></li>
</ul>
<p>Unfortunately, the best documentation for these two advanced features
is the relevant papers at</p>
<ul>
<li><a href="https://ranjitjhala.github.io/static/abstract_refinement_types.pdf">ESOP 2013</a></li>
<li><a href="https://arxiv.org/abs/1507.00385">ICFP 2015</a></li>
</ul>
<p>The bounds correspond to Horn implications between abstract refinements,
which, as in the classical setting, correspond to subtyping constraints
that must be satisfied by the concrete refinements used at any call-site.</p>
<h1 id="dependent-pairs">Dependent Pairs</h1>
<p>Dependent Pairs are expressed by binding the initial tuples of the pair. For example
<code>incrPair</code> defines an increasing pair.</p>
<pre><code>{-@ incrPair :: Int -&gt; (x::Int, {v:Int | x &lt;= v}) @-}
incrPair i = (i, i+1)
</code></pre>
<p>Internally dependent pairs are implemented using abstract refinement types.
That is <code>(x::a, {v:b | p x})</code> desugars to <code>(a,b)&lt;\x -&gt; {v:b | p x}&gt;</code>.</p>
<h1 id="invariants">Invariants</h1>
<p>LH lets you locally associate invariants with specific data types.</p>
<p>For example, in <a href="tests/measure/pos/Using00.hs">tests/measure/pos/Using00.hs</a> every
list is treated as a Stream. To establish this local invariant one can use the
<code>using</code> declaration</p>
<pre><code>{-@ using ([a]) as  {v:[a] | (len v &gt; 0)} @-}
</code></pre>
<p>denoting that each list is not empty.</p>
<p>Then, LiquidHaskell will prove that this invariant holds, by proving that <em>all
calls</em> to List's constructors (ie., <code>:</code> and <code>[]</code>) satisfy it, and
will assume that each list element that is created satisfies
this invariant.</p>
<p>With this, at the <a href="tests/measure/neg/Using00.hs">above</a> test LiquidHaskell
proves that taking the <code>head</code> of a list is safe.
But, at <a href="tests/measure/neg/Using00.hs">tests/measure/neg/Using00.hs</a> the usage of
<code>[]</code> falsifies this local invariant resulting in an "Invariant Check" error.</p>
<p><strong>WARNING:</strong> There is an older <em>global</em> invariant mechanism that
attaches a refinement to a datatype globally.
Do not use this mechanism -- it is <em>unsound</em> and about to
deprecated in favor of something that is <a href="https://github.com/ucsd-progsys/liquidhaskell/issues/126">actually sound</a></p>
<p>For example,  the length of a list cannot be negative</p>
<pre><code>{-@ invariant {v:[a] | (len v &gt;= 0)} @-}
</code></pre>
<p>LiquidHaskell can prove that this invariant holds, by proving that all List's
constructors (ie., <code>:</code> and <code>[]</code>) satisfy it.(TODO!) Then, LiquidHaskell
assumes that each list element that is created satisfies
this invariant.</p>
<h1 id="rewriting">Rewriting</h1>
<p><em>Experimental</em></p>
<p>You use the <code>rewriteWith</code> annotation to indicate equalities that PLE will apply automatically. For example, suppose that you have proven associativity
of <code>++</code> for lists.</p>
<pre><code class="haskell">{-@ assoc :: xs:[a] -&gt; ys:[a] -&gt; zs:[a] 
          -&gt; { xs ++ (ys ++ zs) == (xs ++ ys) ++ zs } @-}
</code></pre>

<p>Using the <code>rewriteWith</code> annotation, PLE will automatically apply the equality for associativity whenever it encounters an expression of the form <code>xs ++ (ys ++ zs)</code> or <code>(xs ++ ys) ++ zs</code>. For example, you can prove <code>assoc2</code> for free.</p>
<pre><code class="haskell">{-@ rewriteWith assoc2 [assoc] @-} 
{-@ assoc2 :: xs:[a] -&gt; ys:[a] -&gt; zs:[a] -&gt; ws:[a]
          -&gt; { xs ++ (ys ++ (zs ++ ws)) == ((xs ++ ys) ++ zs) ++ ws } @-}
assoc2 :: [a] -&gt; [a] -&gt; [a] -&gt; [a] -&gt; ()
assoc2 xs ys zs ws = () 
</code></pre>

<p>You can also annotate a function as being a global rewrite rule by using the
<code>rewrite</code> annotation, in which case PLE will apply it across the entire module.</p>
<pre><code class="haskell">{-@ rewrite assoc @-}
{-@ assoc :: xs:[a] -&gt; ys:[a] -&gt; zs:[a] 
          -&gt; { xs ++ (ys ++ zs) == (xs ++ ys) ++ zs } @-}
</code></pre>

<h3 id="limitations">Limitations</h3>
<p>Currently, rewriting does not work if the equality that uses the rewrite rule
includes parameters that contain inner refinements (<a href="tests/errors/ReWrite5.hs">test</a>).</p>
<p>Rewriting works by pattern-matching expressions to determine if there is a
variable substitution that would allow it to match against either side of a
rewrite rule. If so, that substitution is applied to the opposite side and the
corresponding equality is generated. If one side of the equality contains any
parameters that are not bound on the other side, it will not be possible to
generate a rewrite in that direction, because those variables cannot be
instantiated. Likewise, if there are free variables on both sides of an
equality, no rewrite can be generated at all (<a href="tests/errors/ReWrite7.hs">test</a>).</p>
<p>It's possible in theory for rewriting rules to diverge. We have a simple check 
to ensure that rewriting rules that will always diverge do not get instantiated. 
However, it's possible that applying a combination of rewrite rules could cause
divergence.</p>
<h1 id="formal-grammar-of-refinement-predicates">Formal Grammar of Refinement Predicates</h1>
<h2 id="constants">(C)onstants</h2>
<pre><code>c := 0, 1, 2, ...
</code></pre>
<h2 id="variables">(V)ariables</h2>
<pre><code>v := x, y, z, ...
</code></pre>
<h2 id="expressions">(E)xpressions</h2>
<pre><code>e := v                      -- variable
   | c                      -- constant
   | (e + e)                -- addition
   | (e - e)                -- subtraction
   | (c * e)                -- multiplication by constant
   | (v e1 e2 ... en)       -- uninterpreted function application
   | (if p then e else e)   -- if-then-else
</code></pre>
<h2 id="relations">(R)elations</h2>
<pre><code>r := ==               -- equality
   | /=               -- disequality
   | &gt;=               -- greater than or equal
   | &lt;=               -- less than or equal
   | &gt;                -- greater than
   | &lt;                -- less than
</code></pre>
<h2 id="predicates">(P)redicates</h2>
<pre><code>p := (e r e)          -- binary relation
   | (v e1 e2 ... en) -- predicate (or alias) application
   | (p &amp;&amp; p)         -- and
   | (p || p)         -- or
   | (p =&gt; p)         -- implies
   | (not p)          -- negation
   | true
   | false
</code></pre>
<h1 id="specifying-qualifiers">Specifying Qualifiers</h1>
<p>There are several ways to specify qualifiers.</p>
<h2 id="by-separate-hquals-files">By Separate <code>.hquals</code> Files</h2>
<p>You can write qualifier files e.g. <a href="include/Prelude.hquals">Prelude.hquals</a></p>
<p>If a module is called or imports</p>
<pre><code>Foo.Bar.Baz
</code></pre>
<p>Then the system automatically searches for</p>
<pre><code>include/Foo/Bar/Baz.hquals
</code></pre>
<h2 id="by-including-hquals-files">By Including <code>.hquals</code> Files</h2>
<p>Additional qualifiers may be used by adding lines of the form:</p>
<pre><code>{-@ include &lt;path/to/file.hquals&gt; @-}
</code></pre>
<p>to the Haskell source. See, <a href="tests/pos/meas5.hs">this</a> for example.</p>
<h2 id="in-haskell-source-or-spec-files">In Haskell Source or Spec Files</h2>
<p>Finally, you can specifiers directly inside source (.hs or .lhs) or spec (.spec)
files by writing as shown <a href="tests/pos/qualTest.hs">here</a></p>
<pre><code>{-@ qualif Foo(v:Int, a: Int) : (v = a + 100)   @-}
</code></pre>
<p><strong>Note</strong> In addition to these, LiquidHaskell scrapes qualifiers from all
the specifications you write i.e.</p>
<ol>
<li>all imported type signatures,</li>
<li>measure bodies and,</li>
<li>data constructor definitions.</li>
</ol>
<h2 id="termination-metrics">Termination Metrics</h2>
<p>In recursive functions the <em>first</em> algebraic or integer argument should be decreasing.</p>
<p>The default decreasing measure for lists is length and Integers its value.</p>
<h3 id="default-termination-metrics">Default Termination Metrics</h3>
<p>The user can specify the <em>size</em> of a data-type in the data definition</p>
<pre><code class="haskell">    {-@ data L [llen] a = Nil | Cons { x::a, xs:: L a} @-}
</code></pre>

<p>In the above, the measure <code>llen</code>, which needs to be defined by the user
(see below), is defined as the <em>default metric</em> for the type <code>L a</code>. LH
will use this default metric to <em>automatically</em> prove that the following
terminates:</p>
<pre><code class="haskell">    append :: L a -&gt; L a -&gt; L a  
    append N           ys = ys
    append (Cons x xs) ys = Cons x (append xs ys)
</code></pre>

<p>as, by default the <em>first</em> (non-function) argument with an
associated size metric is checked to be strictly terminating
and non-negative at each recursive call.</p>
<p>A default termination metric is a Haskell function that is proved terminating 
using structural induction. To deactivate structional induction check on the 
termination metric, use the <code>--trust-sizes</code> flag. </p>
<h3 id="explicit-termination-metrics">Explicit Termination Metrics</h3>
<p>However, consider the function <code>reverse</code></p>
<pre><code class="haskell">    reverseAcc :: L a -&gt; L a -&gt; L a  
    reverseAcc acc N           = acc
    reverseAcc acc (Cons x xs) = reverseAcc (Cons x acc) xs
</code></pre>

<p>Here, the first argument does not decrease, instead
the second does. We can tell LH to use the second
argument using the <em>explicit termination metric</em></p>
<pre><code class="haskell">    reverseAcc :: L a -&gt; xs:L a -&gt; L a / [llen xs]  
</code></pre>

<p>which tells LH that the <code>llen</code> of the second argument <code>xs</code>
is what decreases at each recursive call.</p>
<p>Decreasing expressions can be arbitrary refinement expressions, e.g.,</p>
<pre><code class="haskell">    {-@ merge :: Ord a =&gt; xs:L a -&gt; ys:L a -&gt; L a / [llen xs + llen ys] @-}
</code></pre>

<p>states that at each recursive call of <code>merge</code> the <em>sum of the lengths</em>
of its arguments will decrease.</p>
<h3 id="lexicographic-termination-metrics">Lexicographic Termination Metrics</h3>
<p>Some functions do not decrease on a single argument, but rather a
combination of arguments, e.g. the Ackermann function.</p>
<pre><code class="haskell">    {-@ ack :: m:Int -&gt; n:Int -&gt; Nat / [m, n] @-}
    ack m n
      | m == 0          = n + 1
      | m &gt; 0 &amp;&amp; n == 0 = ack (m-1) 1
      | m &gt; 0 &amp;&amp; n &gt;  0 = ack (m-1) (ack m (n-1))
</code></pre>

<p>In all but one recursive call <code>m</code> decreases, in the final call <code>m</code>
does not decrease but <code>n</code> does. We can capture this notion of <code>m</code>
normally decreases, but if it does not, <code>n</code> will decrease with a
<em>lexicographic</em> termination metric <code>[m, n]</code>.</p>
<p>An alternative way to express this specification is by annotating
the function's type with the appropriate <em>numeric</em> decreasing expressions.
As an example, you can give <code>ack</code> a type</p>
<pre><code>{-@ ack :: m:Nat -&gt; n:Nat -&gt; Nat / [m,n] @-}
</code></pre>
<p>stating that the <em>numeric</em> expressions <code>[m, n]</code> are lexicographically decreasing.</p>
<h3 id="mutually-recursive-functions">Mutually Recursive Functions</h3>
<p>When dealing with mutually recursive functions you may run into a
situation where the decreasing parameter must be measured <em>across</em> a
series of invocations, e.g.</p>
<pre><code class="haskell">    even :: Int -&gt; Bool
    even 0 = True
    even n = odd (n-1)

    odd :: Int -&gt; Bool
    odd  n = not (even n)
</code></pre>

<p>In this case, you can introduce a ghost parameter that <em>orders the functions</em></p>
<pre><code class="haskell">    {-@ isEven :: n:Nat -&gt; Bool / [n, 0] @-}
    isEven :: Int -&gt; Bool
    isEven 0 = True
    isEven n = isOdd (n-1)

    {-@ isOdd :: n:Nat -&gt; Bool / [n, 1] @-}
    isOdd :: Int -&gt; Bool
    isOdd  n = not $ isEven n
</code></pre>

<p>thus recovering a decreasing measure for the pair of functions, the
pair of arguments. This can be encoded with the lexicographic
termination annotation as shown above.
See <a href="tests/pos/mutrec.hs">tests/pos/mutrec.hs</a> for the full example.</p>
<h3 id="automatic-termination-metrics">Automatic Termination Metrics</h3>
<p>Apart from specifying a specific decreasing measure for
an Algebraic Data Type, the user can specify that the ADT
follows the expected decreasing measure by</p>
<pre><code class="haskell">    {-@ autosize L @-}
</code></pre>

<p>Then, LH will define an instance of the function <code>autosize</code>
for <code>L</code> that decreases by 1 at each recursive call and use
<code>autosize</code> at functions that recurse on <code>L</code>.</p>
<p>For example, <code>autosize L</code> will refine the data constructors
of <code>L a</code> with the <code>autosize :: a -&gt; Int</code> information, such
that</p>
<pre><code class="haskell">    Nil  :: {v:L a | autosize v = 0}
    Cons :: x:a -&gt; xs:L a -&gt; {v:L a | autosize v = 1 + autosize xs}
</code></pre>

<p>Also, an invariant that <code>autosize</code> is non negative will be generated</p>
<pre><code class="haskell">    invariant  {v:L a| autosize v &gt;= 0 }
</code></pre>

<p>This information is all LiquidHaskell needs to prove termination
on functions that recurse on <code>L a</code> (on ADTs in general.)</p>
<h3 id="disabling-termination-checking">Disabling Termination Checking</h3>
<p>To <em>disable</em> termination checking for <code>foo</code> that is,
to <em>assume</em> that it is terminating (possibly for some
complicated reason currently beyond the scope of LH)
you can write</p>
<pre><code class="haskell">    {-@ lazy foo @-}
</code></pre>

<h2 id="synthesis">Synthesis</h2>
<p>LH has some very preliminary support for program synthesis.</p>
<h3 id="how-to-use-it">How to use it</h3>
<p>Activate the flag for typed holes in LiquidHaskell. E.g.
from command line: </p>
<pre><code>liquid --typedholes
</code></pre>
<p>In a Haskell source file: </p>
<pre><code>{-@ LIQUID --typed-holes @-}
</code></pre>
<p>Using the flag for typed holes, two more flags can be used:</p>
<ul>
<li>
<p><strong>max-match-depth</strong>: Maximum number of pattern match expressions used during synthesis (default value: 4).</p>
</li>
<li>
<p><strong>max-app-depth</strong>: Maximum number of same function applications used during synthesis (default value: 2).</p>
</li>
</ul>
<p>Having the program specified in a Haskell source file, use 
GHC' s hole variables, e.g.:</p>
<pre><code>{-@ myMap :: (a -&gt; b) -&gt; xs:[a] -&gt; {v:[b] | len v == len xs} @-}
myMap :: (a -&gt; b) -&gt; [a] -&gt; [b]
myMap = _goal
</code></pre>
<h3 id="limitations_1">Limitations</h3>
<p>This is an experimental feature, so potential users could only 
expect to synthesize programs, like <a href="https://github.com/ucsd-progsys/liquidhaskell/tree/develop/tests/synth">these</a>.</p>
<p>Current limitations include:</p>
<ul>
<li>No boolean conditionals are synthesized.</li>
<li>
<p>Holes can only appear at top level, e.g.: </p>
<pre><code>{-@ f :: x: [a] -&gt; { v: [a] | v == x } @-}
f :: [a] -&gt; [a]
-- This works
f = _hole
-- This does not work
f x = _hole
</code></pre>
</li>
<li>
<p>Only one hole can appear in each module.</p>
</li>
</ul></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
